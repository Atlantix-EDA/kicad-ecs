// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetCode {
    #[prost(int32, tag = "1")]
    pub value: i32,
}
/// Describes a copper item's net
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Net {
    /// A unique code representing this net
    #[prost(message, optional, tag = "1")]
    pub code: ::core::option::Option<NetCode>,
    /// Human-readable net name
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
/// Represents a track segment on a board
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Track {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(message, optional, tag = "2")]
    pub start: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "3")]
    pub end: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "4")]
    pub width: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "5")]
    pub locked: i32,
    #[prost(enumeration = "BoardLayer", tag = "6")]
    pub layer: i32,
    #[prost(message, optional, tag = "7")]
    pub net: ::core::option::Option<Net>,
}
/// Represents an arc track (not a PCB_SHAPE in arc shape)
/// Arc tracks in KiCad store start, midpoint, and end.
/// All other values (center point, angles, etc) are inferred.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Arc {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(message, optional, tag = "2")]
    pub start: ::core::option::Option<super::super::common::types::Vector2>,
    /// Arc midpoint
    #[prost(message, optional, tag = "3")]
    pub mid: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "4")]
    pub end: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "5")]
    pub width: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "6")]
    pub locked: i32,
    #[prost(enumeration = "BoardLayer", tag = "7")]
    pub layer: i32,
    #[prost(message, optional, tag = "8")]
    pub net: ::core::option::Option<Net>,
}
/// Which corners are chamfered in a PSS_CHAMFEREDRECT
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChamferedRectCorners {
    #[prost(bool, tag = "1")]
    pub top_left: bool,
    #[prost(bool, tag = "2")]
    pub top_right: bool,
    #[prost(bool, tag = "3")]
    pub bottom_left: bool,
    #[prost(bool, tag = "4")]
    pub bottom_right: bool,
}
/// Controls for how copper zones connect to a pad
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneConnectionSettings {
    #[prost(enumeration = "ZoneConnectionStyle", tag = "1")]
    pub zone_connection: i32,
    #[prost(message, optional, tag = "2")]
    pub thermal_spokes: ::core::option::Option<ThermalSpokeSettings>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SolderMaskOverrides {
    /// Solder mask expansion/contraction
    #[prost(message, optional, tag = "1")]
    pub solder_mask_margin: ::core::option::Option<
        super::super::common::types::Distance,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SolderPasteOverrides {
    /// Solder paste expansion/contraction
    #[prost(message, optional, tag = "1")]
    pub solder_paste_margin: ::core::option::Option<
        super::super::common::types::Distance,
    >,
    /// Solder paste expansion/contraction ratio
    #[prost(message, optional, tag = "2")]
    pub solder_paste_margin_ratio: ::core::option::Option<
        super::super::common::types::Ratio,
    >,
}
/// The defintion of a padstack on a single layer
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PadStackLayer {
    /// The board layer of this padstack entry.  For Front/Inner/Back padstacks, In1_Cu is used to represent inner layers.
    #[prost(enumeration = "BoardLayer", tag = "1")]
    pub layer: i32,
    /// The shape of the pad on this layer
    #[prost(enumeration = "PadStackShape", tag = "2")]
    pub shape: i32,
    /// The size (x and y) of the shape on this layer
    #[prost(message, optional, tag = "3")]
    pub size: ::core::option::Option<super::super::common::types::Vector2>,
    /// How much to round the corners of the shape by, as a fraction of min(size.x, size.y)
    /// Only used for PSS_ROUNDRECT or PSS_CHAMFEREDRECT
    #[prost(double, tag = "4")]
    pub corner_rounding_ratio: f64,
    /// How much to round the corners of the shape by, as a fraction of min(size.x, size.y)
    /// Only used for PSS_CHAMFEREDRECT
    #[prost(double, tag = "5")]
    pub chamfer_ratio: f64,
    #[prost(message, optional, tag = "6")]
    pub chamfered_corners: ::core::option::Option<ChamferedRectCorners>,
    #[prost(message, repeated, tag = "7")]
    pub custom_shapes: ::prost::alloc::vec::Vec<BoardGraphicShape>,
    /// If shape == PSS_CUSTOM, defines the shape of the anchor (only PSS_CIRCLE and PSS_RECTANGLE supported at present)
    #[prost(enumeration = "PadStackShape", tag = "8")]
    pub custom_anchor_shape: i32,
    /// Reserved for future use -- at the moment, zone connection settings are not per-layer
    #[prost(message, optional, tag = "9")]
    pub zone_settings: ::core::option::Option<ZoneConnectionSettings>,
    /// The difference in side length between the short and long pads in a trapezoid.  Only one of x or y may be nonzero.
    /// Only used for PSS_TRAPEZOID
    #[prost(message, optional, tag = "10")]
    pub trapezoid_delta: ::core::option::Option<super::super::common::types::Vector2>,
    /// The offset of the center of this shape from the center of the pad (which is defined as the hole center)
    #[prost(message, optional, tag = "11")]
    pub offset: ::core::option::Option<super::super::common::types::Vector2>,
}
/// Properties for the outer technical layers of a padstack on the top or bottom of the stack
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PadStackOuterLayer {
    #[prost(enumeration = "SolderMaskMode", tag = "1")]
    pub solder_mask_mode: i32,
    #[prost(enumeration = "SolderPasteMode", tag = "2")]
    pub solder_paste_mode: i32,
    /// NOTE: At present, KiCad does not support different solder mask expansion settings for the top and bottom layers
    #[prost(message, optional, tag = "3")]
    pub solder_mask_settings: ::core::option::Option<SolderMaskOverrides>,
    /// NOTE: At present, KiCad does not support different solder paste expansion settings for the top and bottom layers
    #[prost(message, optional, tag = "4")]
    pub solder_paste_settings: ::core::option::Option<SolderPasteOverrides>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DrillProperties {
    /// Lowest (closest to F_Cu) layer this drill exists on.
    #[prost(enumeration = "BoardLayer", tag = "1")]
    pub start_layer: i32,
    /// Highest (closest to B_Cu) layer this drill exists on.
    #[prost(enumeration = "BoardLayer", tag = "2")]
    pub end_layer: i32,
    /// The diameter, in x and y, of the pad's drilled hole, if this pad has a hole.
    /// x and y will be the same value if the hole is round.
    #[prost(message, optional, tag = "3")]
    pub diameter: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(enumeration = "DrillShape", tag = "4")]
    pub shape: i32,
}
/// A pad stack definition for a multilayer pad or via.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PadStack {
    /// What type of pad stack this represents.
    #[prost(enumeration = "PadStackType", tag = "1")]
    pub r#type: i32,
    /// The set of board layers this padstack has a definition for
    #[prost(enumeration = "BoardLayer", repeated, tag = "2")]
    pub layers: ::prost::alloc::vec::Vec<i32>,
    /// Properties of the drilled hole in this padstack, if it has one
    #[prost(message, optional, tag = "3")]
    pub drill: ::core::option::Option<DrillProperties>,
    /// How to treat pad shapes on unconnected layers.
    #[prost(enumeration = "UnconnectedLayerRemoval", tag = "4")]
    pub unconnected_layer_removal: i32,
    #[prost(message, repeated, tag = "5")]
    pub copper_layers: ::prost::alloc::vec::Vec<PadStackLayer>,
    /// The overall rotation of this padstack (affects all layers)
    #[prost(message, optional, tag = "6")]
    pub angle: ::core::option::Option<super::super::common::types::Angle>,
    /// Solder mask and paste settings for the front
    #[prost(message, optional, tag = "7")]
    pub front_outer_layers: ::core::option::Option<PadStackOuterLayer>,
    /// Solder mask and paste settings for the back
    #[prost(message, optional, tag = "8")]
    pub back_outer_layers: ::core::option::Option<PadStackOuterLayer>,
    /// Controls for how copper zones connect to the padstack
    #[prost(message, optional, tag = "9")]
    pub zone_settings: ::core::option::Option<ZoneConnectionSettings>,
}
/// Represents a via
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Via {
    /// The unique identifier of the via
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    /// The location of the via's center point
    #[prost(message, optional, tag = "2")]
    pub position: ::core::option::Option<super::super::common::types::Vector2>,
    /// The pad stack definition for this via.
    #[prost(message, optional, tag = "3")]
    pub pad_stack: ::core::option::Option<PadStack>,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "4")]
    pub locked: i32,
    #[prost(message, optional, tag = "5")]
    pub net: ::core::option::Option<Net>,
    #[prost(enumeration = "ViaType", tag = "6")]
    pub r#type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoardGraphicShape {
    #[prost(message, optional, tag = "1")]
    pub shape: ::core::option::Option<super::super::common::types::GraphicShape>,
    #[prost(enumeration = "BoardLayer", tag = "2")]
    pub layer: i32,
    #[prost(message, optional, tag = "3")]
    pub net: ::core::option::Option<Net>,
    #[prost(message, optional, tag = "4")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "5")]
    pub locked: i32,
}
/// A board-specific text object, existing on a board layer
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoardText {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(message, optional, tag = "2")]
    pub text: ::core::option::Option<super::super::common::types::Text>,
    #[prost(enumeration = "BoardLayer", tag = "3")]
    pub layer: i32,
    #[prost(bool, tag = "4")]
    pub knockout: bool,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "5")]
    pub locked: i32,
}
/// A board-specific textbox, existing on a board layer
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoardTextBox {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(message, optional, tag = "2")]
    pub textbox: ::core::option::Option<super::super::common::types::TextBox>,
    #[prost(enumeration = "BoardLayer", tag = "3")]
    pub layer: i32,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "4")]
    pub locked: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThermalSpokeSettings {
    #[prost(message, optional, tag = "1")]
    pub width: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(message, optional, tag = "2")]
    pub angle: ::core::option::Option<super::super::common::types::Angle>,
    #[prost(message, optional, tag = "3")]
    pub gap: ::core::option::Option<super::super::common::types::Distance>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pad {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "2")]
    pub locked: i32,
    #[prost(string, tag = "3")]
    pub number: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub net: ::core::option::Option<Net>,
    #[prost(enumeration = "PadType", tag = "5")]
    pub r#type: i32,
    #[prost(message, optional, tag = "6")]
    pub pad_stack: ::core::option::Option<PadStack>,
    /// A pad's position is always relative to the parent footprint's origin
    #[prost(message, optional, tag = "7")]
    pub position: ::core::option::Option<super::super::common::types::Vector2>,
    /// Copper-to-copper clearance override
    #[prost(message, optional, tag = "8")]
    pub copper_clearance_override: ::core::option::Option<
        super::super::common::types::Distance,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HatchFillSettings {
    #[prost(message, optional, tag = "1")]
    pub thickness: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(message, optional, tag = "2")]
    pub gap: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(message, optional, tag = "3")]
    pub orientation: ::core::option::Option<super::super::common::types::Angle>,
    #[prost(double, tag = "4")]
    pub hatch_smoothing_ratio: f64,
    #[prost(double, tag = "5")]
    pub hatch_hole_min_area_ratio: f64,
    #[prost(enumeration = "ZoneHatchFillBorderMode", tag = "6")]
    pub border_mode: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeardropSettings {
    #[prost(enumeration = "TeardropType", tag = "1")]
    pub r#type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CopperZoneSettings {
    #[prost(message, optional, tag = "1")]
    pub connection: ::core::option::Option<ZoneConnectionSettings>,
    #[prost(message, optional, tag = "2")]
    pub clearance: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(message, optional, tag = "3")]
    pub min_thickness: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(enumeration = "IslandRemovalMode", tag = "4")]
    pub island_mode: i32,
    #[prost(uint64, tag = "5")]
    pub min_island_area: u64,
    #[prost(enumeration = "ZoneFillMode", tag = "6")]
    pub fill_mode: i32,
    #[prost(message, optional, tag = "7")]
    pub hatch_settings: ::core::option::Option<HatchFillSettings>,
    #[prost(message, optional, tag = "8")]
    pub net: ::core::option::Option<Net>,
    #[prost(message, optional, tag = "9")]
    pub teardrop: ::core::option::Option<TeardropSettings>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuleAreaSettings {
    #[prost(bool, tag = "1")]
    pub keepout_copper: bool,
    #[prost(bool, tag = "2")]
    pub keepout_vias: bool,
    #[prost(bool, tag = "3")]
    pub keepout_tracks: bool,
    #[prost(bool, tag = "4")]
    pub keepout_pads: bool,
    #[prost(bool, tag = "5")]
    pub keepout_footprints: bool,
    #[prost(bool, tag = "6")]
    pub placement_enabled: bool,
    #[prost(enumeration = "PlacementRuleSourceType", tag = "7")]
    pub placement_source_type: i32,
    #[prost(string, tag = "8")]
    pub placement_source: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneBorderSettings {
    #[prost(enumeration = "ZoneBorderStyle", tag = "1")]
    pub style: i32,
    #[prost(message, optional, tag = "2")]
    pub pitch: ::core::option::Option<super::super::common::types::Distance>,
}
/// The set of filled polygons of a zone on a single board layer
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneFilledPolygons {
    #[prost(enumeration = "BoardLayer", tag = "1")]
    pub layer: i32,
    #[prost(message, optional, tag = "2")]
    pub shapes: ::core::option::Option<super::super::common::types::PolySet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Zone {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(enumeration = "ZoneType", tag = "2")]
    pub r#type: i32,
    #[prost(enumeration = "BoardLayer", repeated, tag = "3")]
    pub layers: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "4")]
    pub outline: ::core::option::Option<super::super::common::types::PolySet>,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "8")]
    pub priority: u32,
    #[prost(bool, tag = "9")]
    pub filled: bool,
    #[prost(message, repeated, tag = "10")]
    pub filled_polygons: ::prost::alloc::vec::Vec<ZoneFilledPolygons>,
    #[prost(message, optional, tag = "11")]
    pub border: ::core::option::Option<ZoneBorderSettings>,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "12")]
    pub locked: i32,
    #[prost(oneof = "zone::Settings", tags = "6, 7")]
    pub settings: ::core::option::Option<zone::Settings>,
}
/// Nested message and enum types in `Zone`.
pub mod zone {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Settings {
        #[prost(message, tag = "6")]
        CopperSettings(super::CopperZoneSettings),
        #[prost(message, tag = "7")]
        RuleAreaSettings(super::RuleAreaSettings),
    }
}
/// An aligned dimension is drawn parallel to the line segment between the start and end points
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlignedDimensionAttributes {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<super::super::common::types::Vector2>,
    /// Perpendicular distance from dimension endpoints to crossbar
    #[prost(message, optional, tag = "3")]
    pub height: ::core::option::Option<super::super::common::types::Distance>,
    /// Length of extension lines past the crossbar
    #[prost(message, optional, tag = "4")]
    pub extension_height: ::core::option::Option<super::super::common::types::Distance>,
}
/// An orthogonal dimension is drawn parallel to the X or Y axis of the coordinate system
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrthogonalDimensionAttributes {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<super::super::common::types::Vector2>,
    /// Perpendicular distance from dimension endpoints to crossbar
    #[prost(message, optional, tag = "3")]
    pub height: ::core::option::Option<super::super::common::types::Distance>,
    /// Length of extension lines past the crossbar
    #[prost(message, optional, tag = "4")]
    pub extension_height: ::core::option::Option<super::super::common::types::Distance>,
    /// Which axis the dimension is parallel to
    #[prost(enumeration = "super::super::common::types::AxisAlignment", tag = "5")]
    pub alignment: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RadialDimensionAttributes {
    /// The center of the dimensioned circle or arc
    #[prost(message, optional, tag = "1")]
    pub center: ::core::option::Option<super::super::common::types::Vector2>,
    /// A point on the radius of the circle or arc
    #[prost(message, optional, tag = "2")]
    pub radius_point: ::core::option::Option<super::super::common::types::Vector2>,
    /// The distance from radius_point to draw the first segment of the leader line.
    /// The second segment is drawn from the end of the first segment to the text position.
    #[prost(message, optional, tag = "3")]
    pub leader_length: ::core::option::Option<super::super::common::types::Distance>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaderDimensionAttributes {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(enumeration = "DimensionTextBorderStyle", tag = "3")]
    pub border_style: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CenterDimensionAttributes {
    #[prost(message, optional, tag = "1")]
    pub center: ::core::option::Option<super::super::common::types::Vector2>,
    /// A point on the end of one of the four radial spokes drawn from the center point
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<super::super::common::types::Vector2>,
}
/// A dimension in KiCad is a special type of text object.
/// To know the visual appearance of the dimension as rendered by KiCad, use GetTextAsShapes
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dimension {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "2")]
    pub locked: i32,
    #[prost(enumeration = "BoardLayer", tag = "3")]
    pub layer: i32,
    #[prost(message, optional, tag = "4")]
    pub text: ::core::option::Option<super::super::common::types::Text>,
    #[prost(bool, tag = "10")]
    pub override_text_enabled: bool,
    #[prost(string, tag = "11")]
    pub override_text: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub prefix: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub suffix: ::prost::alloc::string::String,
    #[prost(enumeration = "DimensionUnit", tag = "14")]
    pub unit: i32,
    #[prost(enumeration = "DimensionUnitFormat", tag = "15")]
    pub unit_format: i32,
    #[prost(enumeration = "DimensionArrowDirection", tag = "16")]
    pub arrow_direction: i32,
    #[prost(enumeration = "DimensionPrecision", tag = "17")]
    pub precision: i32,
    #[prost(bool, tag = "18")]
    pub suppress_trailing_zeroes: bool,
    #[prost(message, optional, tag = "19")]
    pub line_thickness: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(message, optional, tag = "20")]
    pub arrow_length: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(message, optional, tag = "21")]
    pub extension_offset: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(enumeration = "DimensionTextPosition", tag = "22")]
    pub text_position: i32,
    #[prost(bool, tag = "23")]
    pub keep_text_aligned: bool,
    #[prost(oneof = "dimension::DimensionStyle", tags = "5, 6, 7, 8, 9")]
    pub dimension_style: ::core::option::Option<dimension::DimensionStyle>,
}
/// Nested message and enum types in `Dimension`.
pub mod dimension {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DimensionStyle {
        #[prost(message, tag = "5")]
        Aligned(super::AlignedDimensionAttributes),
        #[prost(message, tag = "6")]
        Orthogonal(super::OrthogonalDimensionAttributes),
        #[prost(message, tag = "7")]
        Radial(super::RadialDimensionAttributes),
        #[prost(message, tag = "8")]
        Leader(super::LeaderDimensionAttributes),
        #[prost(message, tag = "9")]
        Center(super::CenterDimensionAttributes),
    }
}
/// TODO
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReferenceImage {}
/// TODO
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Group {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldId {
    #[prost(int32, tag = "1")]
    pub id: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Field {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<FieldId>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub text: ::core::option::Option<BoardText>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FootprintAttributes {
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub keywords: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub not_in_schematic: bool,
    #[prost(bool, tag = "4")]
    pub exclude_from_position_files: bool,
    #[prost(bool, tag = "5")]
    pub exclude_from_bill_of_materials: bool,
    #[prost(bool, tag = "6")]
    pub exempt_from_courtyard_requirement: bool,
    #[prost(bool, tag = "7")]
    pub do_not_populate: bool,
    #[prost(enumeration = "FootprintMountingStyle", tag = "8")]
    pub mounting_style: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetTieDefinition {
    #[prost(string, repeated, tag = "1")]
    pub pad_number: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FootprintDesignRuleOverrides {
    #[prost(message, optional, tag = "1")]
    pub solder_mask: ::core::option::Option<SolderMaskOverrides>,
    #[prost(message, optional, tag = "2")]
    pub solder_paste: ::core::option::Option<SolderPasteOverrides>,
    #[prost(message, optional, tag = "3")]
    pub copper_clearance: ::core::option::Option<super::super::common::types::Distance>,
    #[prost(enumeration = "ZoneConnectionStyle", tag = "4")]
    pub zone_connection: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Footprint3DModel {
    #[prost(string, tag = "1")]
    pub filename: ::prost::alloc::string::String,
    /// Scaling factor along each axis
    #[prost(message, optional, tag = "2")]
    pub scale: ::core::option::Option<super::super::common::types::Vector3D>,
    /// Rotation around each axis, in degrees
    #[prost(message, optional, tag = "3")]
    pub rotation: ::core::option::Option<super::super::common::types::Vector3D>,
    /// Offset from footprint center
    #[prost(message, optional, tag = "4")]
    pub offset: ::core::option::Option<super::super::common::types::Vector3D>,
    #[prost(bool, tag = "5")]
    pub visible: bool,
    #[prost(double, tag = "6")]
    pub opacity: f64,
}
/// A footprint definition (i.e. what would be in a library)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Footprint {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::LibraryIdentifier>,
    #[prost(message, optional, tag = "2")]
    pub anchor: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "3")]
    pub attributes: ::core::option::Option<FootprintAttributes>,
    #[prost(message, optional, tag = "4")]
    pub overrides: ::core::option::Option<FootprintDesignRuleOverrides>,
    #[prost(message, repeated, tag = "5")]
    pub net_ties: ::prost::alloc::vec::Vec<NetTieDefinition>,
    #[prost(enumeration = "BoardLayer", repeated, tag = "6")]
    pub private_layers: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "7")]
    pub reference_field: ::core::option::Option<Field>,
    #[prost(message, optional, tag = "8")]
    pub value_field: ::core::option::Option<Field>,
    #[prost(message, optional, tag = "9")]
    pub datasheet_field: ::core::option::Option<Field>,
    #[prost(message, optional, tag = "10")]
    pub description_field: ::core::option::Option<Field>,
    /// All footprint items except for mandatory fields
    #[prost(message, repeated, tag = "11")]
    pub items: ::prost::alloc::vec::Vec<::prost_types::Any>,
}
/// An instance of a footprint on a board
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FootprintInstance {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::types::Kiid>,
    #[prost(message, optional, tag = "2")]
    pub position: ::core::option::Option<super::super::common::types::Vector2>,
    #[prost(message, optional, tag = "3")]
    pub orientation: ::core::option::Option<super::super::common::types::Angle>,
    #[prost(enumeration = "BoardLayer", tag = "4")]
    pub layer: i32,
    #[prost(enumeration = "super::super::common::types::LockedState", tag = "5")]
    pub locked: i32,
    #[prost(message, optional, tag = "6")]
    pub definition: ::core::option::Option<Footprint>,
    #[prost(message, optional, tag = "7")]
    pub reference_field: ::core::option::Option<Field>,
    #[prost(message, optional, tag = "8")]
    pub value_field: ::core::option::Option<Field>,
    #[prost(message, optional, tag = "9")]
    pub datasheet_field: ::core::option::Option<Field>,
    #[prost(message, optional, tag = "10")]
    pub description_field: ::core::option::Option<Field>,
    #[prost(message, optional, tag = "11")]
    pub attributes: ::core::option::Option<FootprintAttributes>,
    #[prost(message, optional, tag = "12")]
    pub overrides: ::core::option::Option<FootprintDesignRuleOverrides>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BoardLayer {
    BlUnknown = 0,
    BlUndefined = 1,
    BlUnselected = 2,
    BlFCu = 3,
    BlIn1Cu = 4,
    BlIn2Cu = 5,
    BlIn3Cu = 6,
    BlIn4Cu = 7,
    BlIn5Cu = 8,
    BlIn6Cu = 9,
    BlIn7Cu = 10,
    BlIn8Cu = 11,
    BlIn9Cu = 12,
    BlIn10Cu = 13,
    BlIn11Cu = 14,
    BlIn12Cu = 15,
    BlIn13Cu = 16,
    BlIn14Cu = 17,
    BlIn15Cu = 18,
    BlIn16Cu = 19,
    BlIn17Cu = 20,
    BlIn18Cu = 21,
    BlIn19Cu = 22,
    BlIn20Cu = 23,
    BlIn21Cu = 24,
    BlIn22Cu = 25,
    BlIn23Cu = 26,
    BlIn24Cu = 27,
    BlIn25Cu = 28,
    BlIn26Cu = 29,
    BlIn27Cu = 30,
    BlIn28Cu = 31,
    BlIn29Cu = 32,
    BlIn30Cu = 33,
    BlBCu = 34,
    BlBAdhes = 35,
    BlFAdhes = 36,
    BlBPaste = 37,
    BlFPaste = 38,
    BlBSilkS = 39,
    BlFSilkS = 40,
    BlBMask = 41,
    BlFMask = 42,
    BlDwgsUser = 43,
    BlCmtsUser = 44,
    BlEco1User = 45,
    BlEco2User = 46,
    BlEdgeCuts = 47,
    BlMargin = 48,
    BlBCrtYd = 49,
    BlFCrtYd = 50,
    BlBFab = 51,
    BlFFab = 52,
    BlUser1 = 53,
    BlUser2 = 54,
    BlUser3 = 55,
    BlUser4 = 56,
    BlUser5 = 57,
    BlUser6 = 58,
    BlUser7 = 59,
    BlUser8 = 60,
    BlUser9 = 61,
    BlRescue = 62,
}
impl BoardLayer {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BoardLayer::BlUnknown => "BL_UNKNOWN",
            BoardLayer::BlUndefined => "BL_UNDEFINED",
            BoardLayer::BlUnselected => "BL_UNSELECTED",
            BoardLayer::BlFCu => "BL_F_Cu",
            BoardLayer::BlIn1Cu => "BL_In1_Cu",
            BoardLayer::BlIn2Cu => "BL_In2_Cu",
            BoardLayer::BlIn3Cu => "BL_In3_Cu",
            BoardLayer::BlIn4Cu => "BL_In4_Cu",
            BoardLayer::BlIn5Cu => "BL_In5_Cu",
            BoardLayer::BlIn6Cu => "BL_In6_Cu",
            BoardLayer::BlIn7Cu => "BL_In7_Cu",
            BoardLayer::BlIn8Cu => "BL_In8_Cu",
            BoardLayer::BlIn9Cu => "BL_In9_Cu",
            BoardLayer::BlIn10Cu => "BL_In10_Cu",
            BoardLayer::BlIn11Cu => "BL_In11_Cu",
            BoardLayer::BlIn12Cu => "BL_In12_Cu",
            BoardLayer::BlIn13Cu => "BL_In13_Cu",
            BoardLayer::BlIn14Cu => "BL_In14_Cu",
            BoardLayer::BlIn15Cu => "BL_In15_Cu",
            BoardLayer::BlIn16Cu => "BL_In16_Cu",
            BoardLayer::BlIn17Cu => "BL_In17_Cu",
            BoardLayer::BlIn18Cu => "BL_In18_Cu",
            BoardLayer::BlIn19Cu => "BL_In19_Cu",
            BoardLayer::BlIn20Cu => "BL_In20_Cu",
            BoardLayer::BlIn21Cu => "BL_In21_Cu",
            BoardLayer::BlIn22Cu => "BL_In22_Cu",
            BoardLayer::BlIn23Cu => "BL_In23_Cu",
            BoardLayer::BlIn24Cu => "BL_In24_Cu",
            BoardLayer::BlIn25Cu => "BL_In25_Cu",
            BoardLayer::BlIn26Cu => "BL_In26_Cu",
            BoardLayer::BlIn27Cu => "BL_In27_Cu",
            BoardLayer::BlIn28Cu => "BL_In28_Cu",
            BoardLayer::BlIn29Cu => "BL_In29_Cu",
            BoardLayer::BlIn30Cu => "BL_In30_Cu",
            BoardLayer::BlBCu => "BL_B_Cu",
            BoardLayer::BlBAdhes => "BL_B_Adhes",
            BoardLayer::BlFAdhes => "BL_F_Adhes",
            BoardLayer::BlBPaste => "BL_B_Paste",
            BoardLayer::BlFPaste => "BL_F_Paste",
            BoardLayer::BlBSilkS => "BL_B_SilkS",
            BoardLayer::BlFSilkS => "BL_F_SilkS",
            BoardLayer::BlBMask => "BL_B_Mask",
            BoardLayer::BlFMask => "BL_F_Mask",
            BoardLayer::BlDwgsUser => "BL_Dwgs_User",
            BoardLayer::BlCmtsUser => "BL_Cmts_User",
            BoardLayer::BlEco1User => "BL_Eco1_User",
            BoardLayer::BlEco2User => "BL_Eco2_User",
            BoardLayer::BlEdgeCuts => "BL_Edge_Cuts",
            BoardLayer::BlMargin => "BL_Margin",
            BoardLayer::BlBCrtYd => "BL_B_CrtYd",
            BoardLayer::BlFCrtYd => "BL_F_CrtYd",
            BoardLayer::BlBFab => "BL_B_Fab",
            BoardLayer::BlFFab => "BL_F_Fab",
            BoardLayer::BlUser1 => "BL_User_1",
            BoardLayer::BlUser2 => "BL_User_2",
            BoardLayer::BlUser3 => "BL_User_3",
            BoardLayer::BlUser4 => "BL_User_4",
            BoardLayer::BlUser5 => "BL_User_5",
            BoardLayer::BlUser6 => "BL_User_6",
            BoardLayer::BlUser7 => "BL_User_7",
            BoardLayer::BlUser8 => "BL_User_8",
            BoardLayer::BlUser9 => "BL_User_9",
            BoardLayer::BlRescue => "BL_Rescue",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BL_UNKNOWN" => Some(Self::BlUnknown),
            "BL_UNDEFINED" => Some(Self::BlUndefined),
            "BL_UNSELECTED" => Some(Self::BlUnselected),
            "BL_F_Cu" => Some(Self::BlFCu),
            "BL_In1_Cu" => Some(Self::BlIn1Cu),
            "BL_In2_Cu" => Some(Self::BlIn2Cu),
            "BL_In3_Cu" => Some(Self::BlIn3Cu),
            "BL_In4_Cu" => Some(Self::BlIn4Cu),
            "BL_In5_Cu" => Some(Self::BlIn5Cu),
            "BL_In6_Cu" => Some(Self::BlIn6Cu),
            "BL_In7_Cu" => Some(Self::BlIn7Cu),
            "BL_In8_Cu" => Some(Self::BlIn8Cu),
            "BL_In9_Cu" => Some(Self::BlIn9Cu),
            "BL_In10_Cu" => Some(Self::BlIn10Cu),
            "BL_In11_Cu" => Some(Self::BlIn11Cu),
            "BL_In12_Cu" => Some(Self::BlIn12Cu),
            "BL_In13_Cu" => Some(Self::BlIn13Cu),
            "BL_In14_Cu" => Some(Self::BlIn14Cu),
            "BL_In15_Cu" => Some(Self::BlIn15Cu),
            "BL_In16_Cu" => Some(Self::BlIn16Cu),
            "BL_In17_Cu" => Some(Self::BlIn17Cu),
            "BL_In18_Cu" => Some(Self::BlIn18Cu),
            "BL_In19_Cu" => Some(Self::BlIn19Cu),
            "BL_In20_Cu" => Some(Self::BlIn20Cu),
            "BL_In21_Cu" => Some(Self::BlIn21Cu),
            "BL_In22_Cu" => Some(Self::BlIn22Cu),
            "BL_In23_Cu" => Some(Self::BlIn23Cu),
            "BL_In24_Cu" => Some(Self::BlIn24Cu),
            "BL_In25_Cu" => Some(Self::BlIn25Cu),
            "BL_In26_Cu" => Some(Self::BlIn26Cu),
            "BL_In27_Cu" => Some(Self::BlIn27Cu),
            "BL_In28_Cu" => Some(Self::BlIn28Cu),
            "BL_In29_Cu" => Some(Self::BlIn29Cu),
            "BL_In30_Cu" => Some(Self::BlIn30Cu),
            "BL_B_Cu" => Some(Self::BlBCu),
            "BL_B_Adhes" => Some(Self::BlBAdhes),
            "BL_F_Adhes" => Some(Self::BlFAdhes),
            "BL_B_Paste" => Some(Self::BlBPaste),
            "BL_F_Paste" => Some(Self::BlFPaste),
            "BL_B_SilkS" => Some(Self::BlBSilkS),
            "BL_F_SilkS" => Some(Self::BlFSilkS),
            "BL_B_Mask" => Some(Self::BlBMask),
            "BL_F_Mask" => Some(Self::BlFMask),
            "BL_Dwgs_User" => Some(Self::BlDwgsUser),
            "BL_Cmts_User" => Some(Self::BlCmtsUser),
            "BL_Eco1_User" => Some(Self::BlEco1User),
            "BL_Eco2_User" => Some(Self::BlEco2User),
            "BL_Edge_Cuts" => Some(Self::BlEdgeCuts),
            "BL_Margin" => Some(Self::BlMargin),
            "BL_B_CrtYd" => Some(Self::BlBCrtYd),
            "BL_F_CrtYd" => Some(Self::BlFCrtYd),
            "BL_B_Fab" => Some(Self::BlBFab),
            "BL_F_Fab" => Some(Self::BlFFab),
            "BL_User_1" => Some(Self::BlUser1),
            "BL_User_2" => Some(Self::BlUser2),
            "BL_User_3" => Some(Self::BlUser3),
            "BL_User_4" => Some(Self::BlUser4),
            "BL_User_5" => Some(Self::BlUser5),
            "BL_User_6" => Some(Self::BlUser6),
            "BL_User_7" => Some(Self::BlUser7),
            "BL_User_8" => Some(Self::BlUser8),
            "BL_User_9" => Some(Self::BlUser9),
            "BL_Rescue" => Some(Self::BlRescue),
            _ => None,
        }
    }
}
/// What copper layer shape mode the padstack uses
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PadStackType {
    PstUnknown = 0,
    /// The same shape is used on all copper layers
    PstNormal = 1,
    /// The padstack uses up to three different shapes (F_Cu, inner layers, B_Cu)
    PstFrontInnerBack = 2,
    /// The padstack's shape may differ on arbitrary copper layers
    PstCustom = 3,
}
impl PadStackType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PadStackType::PstUnknown => "PST_UNKNOWN",
            PadStackType::PstNormal => "PST_NORMAL",
            PadStackType::PstFrontInnerBack => "PST_FRONT_INNER_BACK",
            PadStackType::PstCustom => "PST_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PST_UNKNOWN" => Some(Self::PstUnknown),
            "PST_NORMAL" => Some(Self::PstNormal),
            "PST_FRONT_INNER_BACK" => Some(Self::PstFrontInnerBack),
            "PST_CUSTOM" => Some(Self::PstCustom),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UnconnectedLayerRemoval {
    UlrUnknown = 0,
    /// Keep annular rings on all layers
    UlrKeep = 1,
    /// Remove annular rings on unconnected layers, including start and end layers.
    UlrRemove = 2,
    /// Remove annular rings on unconnected layers, but preserve start and end layers even if unconnected.
    UlrRemoveExceptStartAndEnd = 3,
}
impl UnconnectedLayerRemoval {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UnconnectedLayerRemoval::UlrUnknown => "ULR_UNKNOWN",
            UnconnectedLayerRemoval::UlrKeep => "ULR_KEEP",
            UnconnectedLayerRemoval::UlrRemove => "ULR_REMOVE",
            UnconnectedLayerRemoval::UlrRemoveExceptStartAndEnd => {
                "ULR_REMOVE_EXCEPT_START_AND_END"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ULR_UNKNOWN" => Some(Self::UlrUnknown),
            "ULR_KEEP" => Some(Self::UlrKeep),
            "ULR_REMOVE" => Some(Self::UlrRemove),
            "ULR_REMOVE_EXCEPT_START_AND_END" => Some(Self::UlrRemoveExceptStartAndEnd),
            _ => None,
        }
    }
}
/// The shape of a pad on a given layer
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PadStackShape {
    PssUnknown = 0,
    PssCircle = 1,
    PssRectangle = 2,
    PssOval = 3,
    PssTrapezoid = 4,
    PssRoundrect = 5,
    PssChamferedrect = 6,
    PssCustom = 7,
}
impl PadStackShape {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PadStackShape::PssUnknown => "PSS_UNKNOWN",
            PadStackShape::PssCircle => "PSS_CIRCLE",
            PadStackShape::PssRectangle => "PSS_RECTANGLE",
            PadStackShape::PssOval => "PSS_OVAL",
            PadStackShape::PssTrapezoid => "PSS_TRAPEZOID",
            PadStackShape::PssRoundrect => "PSS_ROUNDRECT",
            PadStackShape::PssChamferedrect => "PSS_CHAMFEREDRECT",
            PadStackShape::PssCustom => "PSS_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PSS_UNKNOWN" => Some(Self::PssUnknown),
            "PSS_CIRCLE" => Some(Self::PssCircle),
            "PSS_RECTANGLE" => Some(Self::PssRectangle),
            "PSS_OVAL" => Some(Self::PssOval),
            "PSS_TRAPEZOID" => Some(Self::PssTrapezoid),
            "PSS_ROUNDRECT" => Some(Self::PssRoundrect),
            "PSS_CHAMFEREDRECT" => Some(Self::PssChamferedrect),
            "PSS_CUSTOM" => Some(Self::PssCustom),
            _ => None,
        }
    }
}
/// enum class ZONE_CONNECTION
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneConnectionStyle {
    ZcsUnknown = 0,
    ZcsInherited = 1,
    ZcsNone = 2,
    ZcsThermal = 3,
    ZcsFull = 4,
    /// Thermal reliefs for plated through holes, solid for SMD pads
    ZcsPthThermal = 5,
}
impl ZoneConnectionStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ZoneConnectionStyle::ZcsUnknown => "ZCS_UNKNOWN",
            ZoneConnectionStyle::ZcsInherited => "ZCS_INHERITED",
            ZoneConnectionStyle::ZcsNone => "ZCS_NONE",
            ZoneConnectionStyle::ZcsThermal => "ZCS_THERMAL",
            ZoneConnectionStyle::ZcsFull => "ZCS_FULL",
            ZoneConnectionStyle::ZcsPthThermal => "ZCS_PTH_THERMAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZCS_UNKNOWN" => Some(Self::ZcsUnknown),
            "ZCS_INHERITED" => Some(Self::ZcsInherited),
            "ZCS_NONE" => Some(Self::ZcsNone),
            "ZCS_THERMAL" => Some(Self::ZcsThermal),
            "ZCS_FULL" => Some(Self::ZcsFull),
            "ZCS_PTH_THERMAL" => Some(Self::ZcsPthThermal),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SolderMaskMode {
    SmmUnkown = 0,
    SmmMasked = 1,
    SmmUnmasked = 2,
    SmmFromDesignRules = 3,
}
impl SolderMaskMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SolderMaskMode::SmmUnkown => "SMM_UNKOWN",
            SolderMaskMode::SmmMasked => "SMM_MASKED",
            SolderMaskMode::SmmUnmasked => "SMM_UNMASKED",
            SolderMaskMode::SmmFromDesignRules => "SMM_FROM_DESIGN_RULES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SMM_UNKOWN" => Some(Self::SmmUnkown),
            "SMM_MASKED" => Some(Self::SmmMasked),
            "SMM_UNMASKED" => Some(Self::SmmUnmasked),
            "SMM_FROM_DESIGN_RULES" => Some(Self::SmmFromDesignRules),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SolderPasteMode {
    SpmUnkown = 0,
    SpmPaste = 1,
    SpmNoPaste = 2,
    SpmFromDesignRules = 3,
}
impl SolderPasteMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SolderPasteMode::SpmUnkown => "SPM_UNKOWN",
            SolderPasteMode::SpmPaste => "SPM_PASTE",
            SolderPasteMode::SpmNoPaste => "SPM_NO_PASTE",
            SolderPasteMode::SpmFromDesignRules => "SPM_FROM_DESIGN_RULES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SPM_UNKOWN" => Some(Self::SpmUnkown),
            "SPM_PASTE" => Some(Self::SpmPaste),
            "SPM_NO_PASTE" => Some(Self::SpmNoPaste),
            "SPM_FROM_DESIGN_RULES" => Some(Self::SpmFromDesignRules),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DrillShape {
    DsUnknown = 0,
    DsCircle = 1,
    DsOblong = 2,
    DsUndefined = 3,
}
impl DrillShape {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DrillShape::DsUnknown => "DS_UNKNOWN",
            DrillShape::DsCircle => "DS_CIRCLE",
            DrillShape::DsOblong => "DS_OBLONG",
            DrillShape::DsUndefined => "DS_UNDEFINED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DS_UNKNOWN" => Some(Self::DsUnknown),
            "DS_CIRCLE" => Some(Self::DsCircle),
            "DS_OBLONG" => Some(Self::DsOblong),
            "DS_UNDEFINED" => Some(Self::DsUndefined),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ViaType {
    VtUnknown = 0,
    /// Through vias always start on F_Cu and end on B_Cu
    VtThrough = 1,
    /// Blind/buried vias can have arbitrary start and end layers
    VtBlindBuried = 2,
    /// Microvias, blind/buried vias, can have arbitrary start and end layers, but also have different
    /// size defaults and design rules
    VtMicro = 3,
}
impl ViaType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ViaType::VtUnknown => "VT_UNKNOWN",
            ViaType::VtThrough => "VT_THROUGH",
            ViaType::VtBlindBuried => "VT_BLIND_BURIED",
            ViaType::VtMicro => "VT_MICRO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VT_UNKNOWN" => Some(Self::VtUnknown),
            "VT_THROUGH" => Some(Self::VtThrough),
            "VT_BLIND_BURIED" => Some(Self::VtBlindBuried),
            "VT_MICRO" => Some(Self::VtMicro),
            _ => None,
        }
    }
}
/// NOTE: There has been some discussion about what to do with pad attributes and properties.
/// This may be considered somewhat unstable until we decide what to do with the KiCad side.
/// It is not clear what the set of mutually-exclusive pad types will be at the end of the day,
/// versus what will be non-exclusive attributes/properties.
/// For now, this maps to PAD_ATTRIB in KiCad.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PadType {
    PtUnknown = 0,
    PtPth = 1,
    PtSmd = 2,
    PtEdgeConnector = 3,
    PtNpth = 4,
}
impl PadType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PadType::PtUnknown => "PT_UNKNOWN",
            PadType::PtPth => "PT_PTH",
            PadType::PtSmd => "PT_SMD",
            PadType::PtEdgeConnector => "PT_EDGE_CONNECTOR",
            PadType::PtNpth => "PT_NPTH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PT_UNKNOWN" => Some(Self::PtUnknown),
            "PT_PTH" => Some(Self::PtPth),
            "PT_SMD" => Some(Self::PtSmd),
            "PT_EDGE_CONNECTOR" => Some(Self::PtEdgeConnector),
            "PT_NPTH" => Some(Self::PtNpth),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CustomPadShapeZoneFillStrategy {
    CpszUnknown = 0,
    CpszOutline = 1,
    CpszConvexhull = 2,
}
impl CustomPadShapeZoneFillStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CustomPadShapeZoneFillStrategy::CpszUnknown => "CPSZ_UNKNOWN",
            CustomPadShapeZoneFillStrategy::CpszOutline => "CPSZ_OUTLINE",
            CustomPadShapeZoneFillStrategy::CpszConvexhull => "CPSZ_CONVEXHULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CPSZ_UNKNOWN" => Some(Self::CpszUnknown),
            "CPSZ_OUTLINE" => Some(Self::CpszOutline),
            "CPSZ_CONVEXHULL" => Some(Self::CpszConvexhull),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneType {
    ZtUnknown = 0,
    ZtCopper = 1,
    ZtGraphical = 2,
    ZtRuleArea = 3,
    ZtTeardrop = 4,
}
impl ZoneType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ZoneType::ZtUnknown => "ZT_UNKNOWN",
            ZoneType::ZtCopper => "ZT_COPPER",
            ZoneType::ZtGraphical => "ZT_GRAPHICAL",
            ZoneType::ZtRuleArea => "ZT_RULE_AREA",
            ZoneType::ZtTeardrop => "ZT_TEARDROP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZT_UNKNOWN" => Some(Self::ZtUnknown),
            "ZT_COPPER" => Some(Self::ZtCopper),
            "ZT_GRAPHICAL" => Some(Self::ZtGraphical),
            "ZT_RULE_AREA" => Some(Self::ZtRuleArea),
            "ZT_TEARDROP" => Some(Self::ZtTeardrop),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TeardropType {
    TdtUnknown = 0,
    TdtNone = 1,
    TdtUnspecified = 2,
    TdtViaPad = 3,
    TdtTrackEnd = 4,
}
impl TeardropType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TeardropType::TdtUnknown => "TDT_UNKNOWN",
            TeardropType::TdtNone => "TDT_NONE",
            TeardropType::TdtUnspecified => "TDT_UNSPECIFIED",
            TeardropType::TdtViaPad => "TDT_VIA_PAD",
            TeardropType::TdtTrackEnd => "TDT_TRACK_END",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TDT_UNKNOWN" => Some(Self::TdtUnknown),
            "TDT_NONE" => Some(Self::TdtNone),
            "TDT_UNSPECIFIED" => Some(Self::TdtUnspecified),
            "TDT_VIA_PAD" => Some(Self::TdtViaPad),
            "TDT_TRACK_END" => Some(Self::TdtTrackEnd),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IslandRemovalMode {
    IrmUnknown = 0,
    IrmAlways = 1,
    IrmNever = 2,
    IrmArea = 3,
}
impl IslandRemovalMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            IslandRemovalMode::IrmUnknown => "IRM_UNKNOWN",
            IslandRemovalMode::IrmAlways => "IRM_ALWAYS",
            IslandRemovalMode::IrmNever => "IRM_NEVER",
            IslandRemovalMode::IrmArea => "IRM_AREA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IRM_UNKNOWN" => Some(Self::IrmUnknown),
            "IRM_ALWAYS" => Some(Self::IrmAlways),
            "IRM_NEVER" => Some(Self::IrmNever),
            "IRM_AREA" => Some(Self::IrmArea),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneFillMode {
    ZfmUnknown = 0,
    ZfmSolid = 1,
    ZfmHatched = 2,
}
impl ZoneFillMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ZoneFillMode::ZfmUnknown => "ZFM_UNKNOWN",
            ZoneFillMode::ZfmSolid => "ZFM_SOLID",
            ZoneFillMode::ZfmHatched => "ZFM_HATCHED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZFM_UNKNOWN" => Some(Self::ZfmUnknown),
            "ZFM_SOLID" => Some(Self::ZfmSolid),
            "ZFM_HATCHED" => Some(Self::ZfmHatched),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneHatchSmoothing {
    ZhsUnknown = 0,
    ZhsNone = 1,
    ZhsFillet = 2,
    ZhsArcLowDef = 3,
    ZhsArcHighDef = 4,
}
impl ZoneHatchSmoothing {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ZoneHatchSmoothing::ZhsUnknown => "ZHS_UNKNOWN",
            ZoneHatchSmoothing::ZhsNone => "ZHS_NONE",
            ZoneHatchSmoothing::ZhsFillet => "ZHS_FILLET",
            ZoneHatchSmoothing::ZhsArcLowDef => "ZHS_ARC_LOW_DEF",
            ZoneHatchSmoothing::ZhsArcHighDef => "ZHS_ARC_HIGH_DEF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZHS_UNKNOWN" => Some(Self::ZhsUnknown),
            "ZHS_NONE" => Some(Self::ZhsNone),
            "ZHS_FILLET" => Some(Self::ZhsFillet),
            "ZHS_ARC_LOW_DEF" => Some(Self::ZhsArcLowDef),
            "ZHS_ARC_HIGH_DEF" => Some(Self::ZhsArcHighDef),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneHatchFillBorderMode {
    ZhfbmUnknown = 0,
    ZhfbmUseMinZoneThickness = 1,
    ZhfbmUseHatchThickness = 2,
}
impl ZoneHatchFillBorderMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ZoneHatchFillBorderMode::ZhfbmUnknown => "ZHFBM_UNKNOWN",
            ZoneHatchFillBorderMode::ZhfbmUseMinZoneThickness => {
                "ZHFBM_USE_MIN_ZONE_THICKNESS"
            }
            ZoneHatchFillBorderMode::ZhfbmUseHatchThickness => {
                "ZHFBM_USE_HATCH_THICKNESS"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZHFBM_UNKNOWN" => Some(Self::ZhfbmUnknown),
            "ZHFBM_USE_MIN_ZONE_THICKNESS" => Some(Self::ZhfbmUseMinZoneThickness),
            "ZHFBM_USE_HATCH_THICKNESS" => Some(Self::ZhfbmUseHatchThickness),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlacementRuleSourceType {
    PrstUnknown = 0,
    PrstSheetName = 1,
    PrstComponentClass = 2,
}
impl PlacementRuleSourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PlacementRuleSourceType::PrstUnknown => "PRST_UNKNOWN",
            PlacementRuleSourceType::PrstSheetName => "PRST_SHEET_NAME",
            PlacementRuleSourceType::PrstComponentClass => "PRST_COMPONENT_CLASS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRST_UNKNOWN" => Some(Self::PrstUnknown),
            "PRST_SHEET_NAME" => Some(Self::PrstSheetName),
            "PRST_COMPONENT_CLASS" => Some(Self::PrstComponentClass),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ZoneBorderStyle {
    ZbsUnknown = 0,
    ZbsSolid = 1,
    ZbsDiagonalFull = 2,
    ZbsDiagonalEdge = 3,
    ZbsInvisible = 4,
}
impl ZoneBorderStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ZoneBorderStyle::ZbsUnknown => "ZBS_UNKNOWN",
            ZoneBorderStyle::ZbsSolid => "ZBS_SOLID",
            ZoneBorderStyle::ZbsDiagonalFull => "ZBS_DIAGONAL_FULL",
            ZoneBorderStyle::ZbsDiagonalEdge => "ZBS_DIAGONAL_EDGE",
            ZoneBorderStyle::ZbsInvisible => "ZBS_INVISIBLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZBS_UNKNOWN" => Some(Self::ZbsUnknown),
            "ZBS_SOLID" => Some(Self::ZbsSolid),
            "ZBS_DIAGONAL_FULL" => Some(Self::ZbsDiagonalFull),
            "ZBS_DIAGONAL_EDGE" => Some(Self::ZbsDiagonalEdge),
            "ZBS_INVISIBLE" => Some(Self::ZbsInvisible),
            _ => None,
        }
    }
}
/// The style of the optional frame applied to dimension text
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DimensionTextBorderStyle {
    DtbsUnknown = 0,
    DtbsNone = 1,
    DtbsRectangle = 2,
    DtbsCircle = 3,
    DtbsRoundrect = 4,
}
impl DimensionTextBorderStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DimensionTextBorderStyle::DtbsUnknown => "DTBS_UNKNOWN",
            DimensionTextBorderStyle::DtbsNone => "DTBS_NONE",
            DimensionTextBorderStyle::DtbsRectangle => "DTBS_RECTANGLE",
            DimensionTextBorderStyle::DtbsCircle => "DTBS_CIRCLE",
            DimensionTextBorderStyle::DtbsRoundrect => "DTBS_ROUNDRECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DTBS_UNKNOWN" => Some(Self::DtbsUnknown),
            "DTBS_NONE" => Some(Self::DtbsNone),
            "DTBS_RECTANGLE" => Some(Self::DtbsRectangle),
            "DTBS_CIRCLE" => Some(Self::DtbsCircle),
            "DTBS_ROUNDRECT" => Some(Self::DtbsRoundrect),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DimensionUnitFormat {
    DufUnknown = 0,
    DufNoSuffix = 1,
    DufBareSuffix = 2,
    DufParenSuffix = 3,
}
impl DimensionUnitFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DimensionUnitFormat::DufUnknown => "DUF_UNKNOWN",
            DimensionUnitFormat::DufNoSuffix => "DUF_NO_SUFFIX",
            DimensionUnitFormat::DufBareSuffix => "DUF_BARE_SUFFIX",
            DimensionUnitFormat::DufParenSuffix => "DUF_PAREN_SUFFIX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DUF_UNKNOWN" => Some(Self::DufUnknown),
            "DUF_NO_SUFFIX" => Some(Self::DufNoSuffix),
            "DUF_BARE_SUFFIX" => Some(Self::DufBareSuffix),
            "DUF_PAREN_SUFFIX" => Some(Self::DufParenSuffix),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DimensionArrowDirection {
    DadUnknown = 0,
    DadInward = 1,
    DadOutward = 2,
}
impl DimensionArrowDirection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DimensionArrowDirection::DadUnknown => "DAD_UNKNOWN",
            DimensionArrowDirection::DadInward => "DAD_INWARD",
            DimensionArrowDirection::DadOutward => "DAD_OUTWARD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DAD_UNKNOWN" => Some(Self::DadUnknown),
            "DAD_INWARD" => Some(Self::DadInward),
            "DAD_OUTWARD" => Some(Self::DadOutward),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DimensionPrecision {
    DpUnknown = 0,
    /// No digits after decimal point
    DpFixed0 = 1,
    /// 1 digit after decimal point
    DpFixed1 = 2,
    /// 2 digits after decimal point
    DpFixed2 = 3,
    /// 3 digits after decimal point
    DpFixed3 = 4,
    /// 4 digits after decimal point
    DpFixed4 = 5,
    /// 5 digits after decimal point
    DpFixed5 = 6,
    /// Precision depends on unit selection; 2 digits for inches, 0 for mils, 1 for mm
    DpScaledIn2 = 7,
    /// Precision depends on unit selection; 3 digits for inches, 0 for mils, 2 for mm
    DpScaledIn3 = 8,
    /// Precision depends on unit selection; 4 digits for inches, 1 for mils, 3 for mm
    DpScaledIn4 = 9,
    /// Precision depends on unit selection; 5 digits for inches, 2 for mils, 4 for mm
    DpScaledIn5 = 10,
}
impl DimensionPrecision {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DimensionPrecision::DpUnknown => "DP_UNKNOWN",
            DimensionPrecision::DpFixed0 => "DP_FIXED_0",
            DimensionPrecision::DpFixed1 => "DP_FIXED_1",
            DimensionPrecision::DpFixed2 => "DP_FIXED_2",
            DimensionPrecision::DpFixed3 => "DP_FIXED_3",
            DimensionPrecision::DpFixed4 => "DP_FIXED_4",
            DimensionPrecision::DpFixed5 => "DP_FIXED_5",
            DimensionPrecision::DpScaledIn2 => "DP_SCALED_IN_2",
            DimensionPrecision::DpScaledIn3 => "DP_SCALED_IN_3",
            DimensionPrecision::DpScaledIn4 => "DP_SCALED_IN_4",
            DimensionPrecision::DpScaledIn5 => "DP_SCALED_IN_5",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DP_UNKNOWN" => Some(Self::DpUnknown),
            "DP_FIXED_0" => Some(Self::DpFixed0),
            "DP_FIXED_1" => Some(Self::DpFixed1),
            "DP_FIXED_2" => Some(Self::DpFixed2),
            "DP_FIXED_3" => Some(Self::DpFixed3),
            "DP_FIXED_4" => Some(Self::DpFixed4),
            "DP_FIXED_5" => Some(Self::DpFixed5),
            "DP_SCALED_IN_2" => Some(Self::DpScaledIn2),
            "DP_SCALED_IN_3" => Some(Self::DpScaledIn3),
            "DP_SCALED_IN_4" => Some(Self::DpScaledIn4),
            "DP_SCALED_IN_5" => Some(Self::DpScaledIn5),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DimensionTextPosition {
    DtpUnknown = 0,
    DtpOutside = 1,
    DtpInline = 2,
    DtpManual = 3,
}
impl DimensionTextPosition {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DimensionTextPosition::DtpUnknown => "DTP_UNKNOWN",
            DimensionTextPosition::DtpOutside => "DTP_OUTSIDE",
            DimensionTextPosition::DtpInline => "DTP_INLINE",
            DimensionTextPosition::DtpManual => "DTP_MANUAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DTP_UNKNOWN" => Some(Self::DtpUnknown),
            "DTP_OUTSIDE" => Some(Self::DtpOutside),
            "DTP_INLINE" => Some(Self::DtpInline),
            "DTP_MANUAL" => Some(Self::DtpManual),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DimensionUnit {
    DuUnknown = 0,
    DuInches = 1,
    DuMils = 2,
    DuMillimeters = 3,
    DuAutomatic = 4,
}
impl DimensionUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DimensionUnit::DuUnknown => "DU_UNKNOWN",
            DimensionUnit::DuInches => "DU_INCHES",
            DimensionUnit::DuMils => "DU_MILS",
            DimensionUnit::DuMillimeters => "DU_MILLIMETERS",
            DimensionUnit::DuAutomatic => "DU_AUTOMATIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DU_UNKNOWN" => Some(Self::DuUnknown),
            "DU_INCHES" => Some(Self::DuInches),
            "DU_MILS" => Some(Self::DuMils),
            "DU_MILLIMETERS" => Some(Self::DuMillimeters),
            "DU_AUTOMATIC" => Some(Self::DuAutomatic),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FootprintMountingStyle {
    FmsUnknown = 0,
    FmsThroughHole = 1,
    FmsSmd = 2,
    FmsUnspecified = 3,
}
impl FootprintMountingStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FootprintMountingStyle::FmsUnknown => "FMS_UNKNOWN",
            FootprintMountingStyle::FmsThroughHole => "FMS_THROUGH_HOLE",
            FootprintMountingStyle::FmsSmd => "FMS_SMD",
            FootprintMountingStyle::FmsUnspecified => "FMS_UNSPECIFIED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FMS_UNKNOWN" => Some(Self::FmsUnknown),
            "FMS_THROUGH_HOLE" => Some(Self::FmsThroughHole),
            "FMS_SMD" => Some(Self::FmsSmd),
            "FMS_UNSPECIFIED" => Some(Self::FmsUnspecified),
            _ => None,
        }
    }
}
