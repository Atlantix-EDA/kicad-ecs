// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBoardStackup {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoardStackupResponse {
    #[prost(message, optional, tag = "1")]
    pub stackup: ::core::option::Option<super::BoardStackup>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBoardStackup {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    #[prost(message, optional, tag = "2")]
    pub stackup: ::core::option::Option<super::BoardStackup>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGraphicsDefaults {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GraphicsDefaultsResponse {
    #[prost(message, optional, tag = "1")]
    pub defaults: ::core::option::Option<super::GraphicsDefaults>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNets {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    /// If provided, will only return nets that belong to the given netclass.
    /// If more than one netclass_filter is given, nets belonging to any of the given classes will
    /// be returned.
    #[prost(string, repeated, tag = "2")]
    pub netclass_filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub nets: ::prost::alloc::vec::Vec<super::types::Net>,
}
/// Retrieve all the copper items belonging to a certain net or set of nets
/// returns kiapi.common.commands.GetItemsResponse
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetItemsByNet {
    /// Specifies which document to query, which fields to return, etc.
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<super::super::common::types::ItemHeader>,
    /// List of one or more types of items to retreive
    #[prost(
        enumeration = "super::super::common::types::KiCadObjectType",
        repeated,
        tag = "2"
    )]
    pub types: ::prost::alloc::vec::Vec<i32>,
    /// A list of net codes to filter items by
    #[prost(message, repeated, tag = "3")]
    pub net_codes: ::prost::alloc::vec::Vec<super::types::NetCode>,
}
/// Retrieve all the copper items belonging to a certain net class or set of net classes
/// returns kiapi.common.commands.GetItemsResponse
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetItemsByNetClass {
    /// Specifies which document to query, which fields to return, etc.
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<super::super::common::types::ItemHeader>,
    /// List of one or more types of items to retreive
    #[prost(
        enumeration = "super::super::common::types::KiCadObjectType",
        repeated,
        tag = "2"
    )]
    pub types: ::prost::alloc::vec::Vec<i32>,
    /// A list of net class names to filter items by
    #[prost(string, repeated, tag = "3")]
    pub net_classes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A net may be part of multiple classes that have a priority ordering, which will result in a
/// composite "effective" netclass containing the merged/overridden properties of all the constituent
/// netclasses it contains.  This message retrieves this effective netclass for a net or list of
/// nets.
/// Returns NetClassForNetsResponse
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetClassForNets {
    #[prost(message, repeated, tag = "1")]
    pub net: ::prost::alloc::vec::Vec<super::types::Net>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetClassForNetsResponse {
    /// Map of net name to netclass info
    #[prost(map = "string, message", tag = "1")]
    pub classes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::common::project::NetClass,
    >,
}
/// Refills some or all zones on the board.
/// This is a blocking operation; it will return Empty immediately, but KiCad will return
/// ApiStatusCode.AS_BUSY to all future API requests until the zone fill has completed.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefillZones {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    /// A list of zones to refill.  If empty, all zones are refilled.
    #[prost(message, repeated, tag = "2")]
    pub zones: ::prost::alloc::vec::Vec<super::super::common::types::Kiid>,
}
/// Computes the polygon representation of a pad, merging any custom shapes together.
/// This representation will approximate curves as a series of segments.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPadShapeAsPolygon {
    /// The board to process
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    /// A list of one or more pads to process
    #[prost(message, repeated, tag = "2")]
    pub pads: ::prost::alloc::vec::Vec<super::super::common::types::Kiid>,
    /// The layer to process
    #[prost(enumeration = "super::types::BoardLayer", tag = "3")]
    pub layer: i32,
}
/// Returned from GetPadShapeAsPolygon.  The pads and polygons repeated fields will have the same length
/// and can be treated as a list of tuples.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PadShapeAsPolygonResponse {
    /// The pads that were processed
    #[prost(message, repeated, tag = "1")]
    pub pads: ::prost::alloc::vec::Vec<super::super::common::types::Kiid>,
    /// The polygon representation of each pad
    #[prost(message, repeated, tag = "2")]
    pub polygons: ::prost::alloc::vec::Vec<
        super::super::common::types::PolygonWithHoles,
    >,
}
/// returns BoardLayers
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVisibleLayers {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoardLayerResponse {
    #[prost(enumeration = "super::types::BoardLayer", tag = "1")]
    pub layer: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoardLayers {
    #[prost(enumeration = "super::types::BoardLayer", repeated, tag = "1")]
    pub layers: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetVisibleLayers {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    #[prost(enumeration = "super::types::BoardLayer", repeated, tag = "2")]
    pub layers: ::prost::alloc::vec::Vec<i32>,
}
/// returns BoardLayerResponse
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActiveLayer {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetActiveLayer {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    #[prost(enumeration = "super::types::BoardLayer", tag = "2")]
    pub layer: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoardEditorAppearanceSettings {
    #[prost(enumeration = "InactiveLayerDisplayMode", tag = "1")]
    pub inactive_layer_display: i32,
    #[prost(enumeration = "NetColorDisplayMode", tag = "2")]
    pub net_color_display: i32,
    #[prost(enumeration = "BoardFlipMode", tag = "3")]
    pub board_flip: i32,
    #[prost(enumeration = "RatsnestDisplayMode", tag = "4")]
    pub ratsnest_display: i32,
}
/// Returns BoardEditorAppearanceSettings
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBoardEditorAppearanceSettings {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetBoardEditorAppearanceSettings {
    #[prost(message, optional, tag = "1")]
    pub settings: ::core::option::Option<BoardEditorAppearanceSettings>,
}
/// Selects and begins an interactive move of the given item(s).
/// NOTE: Takes ownership of the active commit, if one exists:
///        the move tool will push the commit when the user confirms the move,
///        or roll back the commit if the user cancels the move.  Keep this in
///        mind if using this command in combination with commands that create
///        or modify items using an explicit commit.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InteractiveMoveItems {
    #[prost(message, optional, tag = "1")]
    pub board: ::core::option::Option<super::super::common::types::DocumentSpecifier>,
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<super::super::common::types::Kiid>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InactiveLayerDisplayMode {
    IldmUnknown = 0,
    /// Inactive layers are shown
    IldmNormal = 1,
    /// Inactive layers are shown with dimmed colors
    IldmDimmed = 2,
    /// Inactive layers are hidden
    IldmHidden = 3,
}
impl InactiveLayerDisplayMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            InactiveLayerDisplayMode::IldmUnknown => "ILDM_UNKNOWN",
            InactiveLayerDisplayMode::IldmNormal => "ILDM_NORMAL",
            InactiveLayerDisplayMode::IldmDimmed => "ILDM_DIMMED",
            InactiveLayerDisplayMode::IldmHidden => "ILDM_HIDDEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ILDM_UNKNOWN" => Some(Self::IldmUnknown),
            "ILDM_NORMAL" => Some(Self::IldmNormal),
            "ILDM_DIMMED" => Some(Self::IldmDimmed),
            "ILDM_HIDDEN" => Some(Self::IldmHidden),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NetColorDisplayMode {
    NcdmUnknown = 0,
    /// Net and netclass colors are shown in the ratsnest and on all copper items
    NcdmAll = 1,
    /// Net and netclass colors are shown in the ratsnest only
    NcdmRatsnest = 2,
    /// Net and netclass colors are not shown
    NcdmOff = 3,
}
impl NetColorDisplayMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            NetColorDisplayMode::NcdmUnknown => "NCDM_UNKNOWN",
            NetColorDisplayMode::NcdmAll => "NCDM_ALL",
            NetColorDisplayMode::NcdmRatsnest => "NCDM_RATSNEST",
            NetColorDisplayMode::NcdmOff => "NCDM_OFF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NCDM_UNKNOWN" => Some(Self::NcdmUnknown),
            "NCDM_ALL" => Some(Self::NcdmAll),
            "NCDM_RATSNEST" => Some(Self::NcdmRatsnest),
            "NCDM_OFF" => Some(Self::NcdmOff),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BoardFlipMode {
    BfmUnknown = 0,
    /// Normal ("non-flipped") mode
    BfmNormal = 1,
    /// "Flipped" mode, viewed from the back and mirrored around the X axis
    BfmFlippedX = 2,
}
impl BoardFlipMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BoardFlipMode::BfmUnknown => "BFM_UNKNOWN",
            BoardFlipMode::BfmNormal => "BFM_NORMAL",
            BoardFlipMode::BfmFlippedX => "BFM_FLIPPED_X",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BFM_UNKNOWN" => Some(Self::BfmUnknown),
            "BFM_NORMAL" => Some(Self::BfmNormal),
            "BFM_FLIPPED_X" => Some(Self::BfmFlippedX),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RatsnestDisplayMode {
    RdmUnknown = 0,
    /// Ratsnest lines are drawn to objects even if they are on hidden layers
    RdmAllLayers = 1,
    /// Ratsnest lines are hidden when at least one endpoint is an item on a hidden layer
    RdmVisibleLayers = 2,
}
impl RatsnestDisplayMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RatsnestDisplayMode::RdmUnknown => "RDM_UNKNOWN",
            RatsnestDisplayMode::RdmAllLayers => "RDM_ALL_LAYERS",
            RatsnestDisplayMode::RdmVisibleLayers => "RDM_VISIBLE_LAYERS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RDM_UNKNOWN" => Some(Self::RdmUnknown),
            "RDM_ALL_LAYERS" => Some(Self::RdmAllLayers),
            "RDM_VISIBLE_LAYERS" => Some(Self::RdmVisibleLayers),
            _ => None,
        }
    }
}
